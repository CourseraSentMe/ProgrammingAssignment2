## Here are two functions that allow you to:
## 1. Create a special object that includes an invertable and
## cache-able matrix.
## 2. Calculate and cache the inverse of this matrix. Then retrieve
## the cached inverse matrix rather than calculate it all over again. Also,
## let you know if it is retrieving the cached inverse matrix rather than
## calculating it.

## This function allows you to create a special object that includes an invertable 
## and cache-able matrix.
## It takes an invertable matrix as an arguement.
## Note that not all matrices are invertable.
## To be invertable a matrix must be square, nonsingular or nondegenerate.
## Using a matrix that is not invertable will cause errors.
## To test code you can use this matrix: matrix(1:4,2,2)

makeCacheMatrix <- function(x = matrix()) {
  m <- NULL
  set <- function(y) {
    x <<- y
    m <<- NULL
  }
  get <- function() x
  setinv <- function(solve) m <<- solve
  getinv <- function() m
  list(set = set, get = get, setinv = setinv, getinv = getinv)
}


## This function allows you to calculate and cache the inverse matrix of the
## matrix generated by the makeCacheMatrix function.
## If the inverse matrix has already been calculated and cached it will retrieve
## the cached matrix rather than recalculate it and it will let you know by
## printing a message saying "getting cached data" before returning
## the cached inverse matrix.

cacheSolve <- function(x, ...) {
  m <- x$getinv()
  if(!is.null(m)) {
    message("getting cached data")
    return(m)
  }
  data <- x$get()
  m <- solve(data, ...) 
  x$setinv(m)
  m
}
